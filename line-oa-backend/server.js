require('dotenv').config();
const express = require('express');
const db = require('./db')
const line = require('@line/bot-sdk');
const route_product = require("./routes/route_product");
const axios = require("axios");
const app = express();
const cors = require('cors')
const cron = require("node-cron");
const { sendProductsToLine } = require("./controllers/manage_Product");
const route_order = require('./routes/route_order');
const route_orderitem = require('./routes/route_orderitems');
const route_ingredientitems = require('./routes/route_ingredientitems');
const route_ingredient = require('./routes/route_ingredient');
const { checkIngredientsAvailability, deductIngredientsFromStock } = require("./controllers/manage_Order");

const path = require("path");
const { exec } = require("child_process");

const EventEmitter = require('events');
EventEmitter.defaultMaxListeners = 20; // ‡πÄ‡∏û‡∏¥‡πà‡∏° Limit ‡∏Ç‡∏≠‡∏á EventEmitter




app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(cors());
app.use('/api/products', route_product);
app.use("/uploads", express.static("uploads"));
app.use("/api/orders", route_order);
app.use("/api/order_items",route_orderitem);
app.use("/api/ingredient",route_ingredient);
app.use("/api/ingredientItems",route_ingredientitems);


const config = {
    channelAccessToken: process.env.CHANNEL_ACCESS_TOKEN,
    channelSecret: process.env.CHANNEL_SECRET,
};

if (!config.channelAccessToken || !config.channelSecret) {
    throw new Error("Missing CHANNEL_ACCESS_TOKEN or CHANNEL_SECRET in .env file");
}




const client = new line.Client(config);

app.get('/', async (req, res) => {
    try {
        res.send('Hello, LINE OA is running!');
    } catch (error) {
        console.log(error)
    }

});






async function getUserProfile(userId) {
    try {
        const response = await axios.get(`https://api.line.me/v2/bot/profile/${userId}`, {
            headers: {
                "Authorization": `Bearer ${config.channelAccessToken}`
            }
        });
        return response.data;
    } catch (error) {
        console.error("üö® Error getting user profile:", error);
        return null;
    }
}


app.post("/webhook", async (req, res) => {
    const events = req.body.events;

    for (let event of events) {
        if (event.type === "message" && event.message.type === "text") {
            let customerId = event.source.userId;
            let customerText = event.message.text;
            let customerName = "‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤";

            try {
                // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏û‡∏¥‡∏°‡∏û‡πå‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                const [waitingOrder] = await db.query(
                    "SELECT Order_ID FROM `Order` WHERE Customer_ID = ? AND Status = 'Awaiting Address'",
                    [customerId]
                );

                if (waitingOrder.length > 0) {
                    let orderId = waitingOrder[0].Order_ID;

                    // ‚úÖ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏•‡∏á‡πÉ‡∏ô Order
                    await db.query(
                        "UPDATE `Order` SET Customer_Address = ?, Status = 'Preparing' WHERE Order_ID = ?",
                        [customerText, orderId]
                    );

                    // ‚úÖ ‡πÅ‡∏à‡πâ‡∏á‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏ß‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏ñ‡∏π‡∏Å‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÅ‡∏•‡πâ‡∏ß
                    await client.replyMessage(event.replyToken, {
                        type: "text",
                        text: `‚úÖ ‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏ñ‡∏π‡∏Å‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß!\nüìç ‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà: ${customerText}\nüõµ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì`
                    });

                    return;
                }

                // ‚úÖ ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÇ‡∏õ‡∏£‡πÑ‡∏ü‡∏•‡πå‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤
                const profile = await getUserProfile(customerId);
                if (profile) {
                    customerName = profile.displayName;
                }

                // ‚úÖ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤ (‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ)
                await db.query(
                    `INSERT INTO Customer (Customer_ID, Customer_Name) VALUES (?, ?) 
                     ON DUPLICATE KEY UPDATE Customer_Name = VALUES(Customer_Name)`,
                    [customerId, customerName]
                );

                // ‚úÖ ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÇ‡∏°‡πÄ‡∏î‡∏• Python
                const modelPath = path.join(__dirname, "..", "model", "model.py");
                exec(`python "${modelPath}" "${customerText}"`, async (error, stdout) => {
                    if (error) {
                        console.error("‚ùå Error running model:", error);
                        return;
                    }

                    let orders;
                    try {
                        orders = JSON.parse(stdout);
                    } catch (parseError) {
                        console.error("‚ùå JSON Parse Error:", parseError);
                        await client.replyMessage(event.replyToken, { type: "text", text: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà" });
                        return;
                    }

                    if (!Array.isArray(orders) || orders.length === 0) {
                        await client.replyMessage(event.replyToken, { type: "text", text: "‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì" });
                        return;
                    }

                    let totalAmount = 0;
                    let orderItems = [];

                    for (let order of orders) {
                        const [rows] = await db.query(
                            "SELECT Price FROM Product WHERE Product_ID = ?",
                            [order.Product_ID]
                        );
                        if (!rows.length) continue;

                        let price = parseFloat(rows[0].Price);
                        let subtotal = price * order.quantity;
                        totalAmount += subtotal;

                        orderItems.push({
                            product_id: order.Product_ID,
                            menu: order.menu,
                            quantity: order.quantity,
                            subtotal: subtotal
                        });
                    }

                    // ‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á Flex Message ‡πÉ‡∏´‡πâ‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô (‡πÅ‡∏ï‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡∏á Database)
                    const confirmMessage = {
                        type: "flex",
                        altText: "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠",
                        contents: {
                            type: "bubble",
                            body: {
                                type: "box",
                                layout: "vertical",
                                contents: [
                                    { type: "text", text: "‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠", weight: "bold", size: "xl" },
                                    ...orderItems.map(order => ({
                                        type: "text",
                                        text: `- ${order.menu} x ${order.quantity} ‡∏ä‡∏¥‡πâ‡∏ô (${order.subtotal} ‡∏ö‡∏≤‡∏ó)`,
                                        wrap: true
                                    })),
                                    { type: "text", text: `üí∞ ‡∏¢‡∏≠‡∏î‡∏£‡∏ß‡∏°: ${totalAmount} ‡∏ö‡∏≤‡∏ó`, weight: "bold", margin: "md" }
                                ]
                            },
                            footer: {
                                type: "box",
                                layout: "horizontal",
                                spacing: "sm",
                                contents: [
                                    {
                                        type: "button",
                                        style: "primary",
                                        color: "#1DB446",
                                        action: {
                                            type: "postback",
                                            label: "Confirm",
                                            data: JSON.stringify({ action: "confirm_order", customerId, orderItems, totalAmount })
                                        }
                                    },
                                    {
                                        type: "button",
                                        style: "secondary",
                                        color: "#AAAAAA",
                                        action: {
                                            type: "postback",
                                            label: "Cancel",
                                            data: JSON.stringify({ action: "cancel_order", customerId })
                                        }
                                    }
                                ]
                            }
                        }
                    };

                    // ‚úÖ ‡∏™‡πà‡∏á Flex Message ‡πÉ‡∏´‡πâ‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏Å‡∏î‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô
                    await client.replyMessage(event.replyToken, confirmMessage);
                });

            } catch (error) {
                console.error("üö® Error processing order:", error);
            }
        } 
        
        // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏° Confirm ‡∏´‡∏£‡∏∑‡∏≠ Cancel
        else if (event.type === "postback") {
            let data;
            try {
                data = JSON.parse(event.postback.data);
            } catch (error) {
                console.error("‚ùå JSON Parse Error in postback:", error);
                return;
            }
        
        
            if (data.action === "confirm_order") {
                try {
                    // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏î‡∏¥‡∏ö‡∏Å‡πà‡∏≠‡∏ô
                    const ingredientCheck = await checkIngredientsAvailability(data.orderItems);
                    if (!ingredientCheck.success) {
                        await client.replyMessage(event.replyToken, {
                            type: "text",
                            text: ingredientCheck.message
                        });
                        return;
                    }
            
                    // ‚úÖ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å Order ‡∏•‡∏á‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
                    const [orderResult] = await db.query(
                        "INSERT INTO `Order` (Customer_ID, Total_Amount, Customer_Address, Status) VALUES (?, ?, NULL, 'Awaiting Address')",
                        [data.customerId, data.totalAmount]
                    );
                    const orderId = orderResult.insertId;
            
                    // ‚úÖ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å Order Items
                    for (let item of data.orderItems) {
                        await db.query(
                            "INSERT INTO Order_Item (Order_ID, Product_ID, Quantity, Subtotal, Status) VALUES (?, ?, ?, ?, 'Preparing')",
                            [orderId, item.product_id, item.quantity, item.subtotal]
                        );
                    }
            
                    // ‚úÖ ‡∏´‡∏±‡∏Å‡∏™‡∏ï‡πá‡∏≠‡∏Å‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏î‡∏¥‡∏ö
                    await deductIngredientsFromStock(data.orderItems);
            
                    // ‚úÖ ‡πÅ‡∏à‡πâ‡∏á‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡πÉ‡∏´‡πâ‡∏™‡πà‡∏á‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà
                    await client.replyMessage(event.replyToken, {
                        type: "text",
                        text: "‚úÖ ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡πÅ‡∏•‡πâ‡∏ß!\nüìç ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏™‡πà‡∏á‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏î‡∏™‡πà‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì"
                    });
            
                } catch (error) {
                    console.error("‚ùå Error saving order:", error);
                    await client.replyMessage(event.replyToken, { type: "text", text: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà" });
                }
            }
            else if (data.action === "cancel_order") {
                // ‚úÖ ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÉ‡∏´‡∏°‡πà‡πÅ‡∏ó‡∏ô‡∏õ‡∏∏‡πà‡∏°
                await client.replyMessage(event.replyToken, {
                    type: "text",
                    text: "‚ùå ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏ñ‡∏π‡∏Å‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß"
                });
            }
        }
    }

    res.sendStatus(200);
});







// const sendProductMenuToLine = async () => {
//     try {
//         const flexMessage = await generateProductMenu();
//         if (!flexMessage) {
//             console.log("‚ùå ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö");
//             return;
//         }


//         const [recipients] = await db.query("SELECT Customer_ID FROM Customer"); 
//         await client.pushMessage(recipients, flexMessage);

//         console.log("‚úÖ ‡∏™‡πà‡∏á‡πÄ‡∏°‡∏ô‡∏π‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÑ‡∏õ‡∏¢‡∏±‡∏á LINE OA ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!");
//     } catch (error) {
//         console.error("üö® ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡πà‡∏á‡πÄ‡∏°‡∏ô‡∏π‡πÑ‡∏õ‡∏¢‡∏±‡∏á LINE OA:", error);
//     }
// };


cron.schedule("0 12 * * *", async () => {
    console.log("üîî ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡πà‡∏á‡πÄ‡∏°‡∏ô‡∏π‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÑ‡∏õ‡∏¢‡∏±‡∏á LINE...");
    try {
        await sendProductsToLine();
    } catch (error) {
        console.error("Error sending menu:", error);
    }
    
}, {
    scheduled: true,
    timezone: "Asia/Bangkok"
});



(async () => {
    try {

        const [rows] = await db.query('SHOW TABLES;');
        console.log('Connected to Database. Tables:', rows);

    } catch (err) {

        console.error('Database connection error:', err);

    }
})();



const PORT = 3000;
app.listen(PORT, () => {
    console.log('Server is running on port 3000');
});



